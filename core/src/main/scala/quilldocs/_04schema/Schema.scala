package quilldocs._04schema

import scala.util.chaining._

import hutil.stringformat._

import io.getquill._

object Schema extends hutil.App {

  val ctx = new SqlMirrorContext(PostgresDialect, SnakeCase)

  import ctx._

  case class Circle(radius: Float)
  case class Rectangle(length: Int, width: Int)

  s"$dash10 Schema $dash10".magenta.println

  // The database schema is represented by case classes. By default, quill uses
  // the class and field names as the database identifiers:

  val q1 = quote {
    query[Circle].filter(c => c.radius > 1)
  }
  q1.ast pipe println

  val run1 = ctx.run(q1)
  // SELECT c.radius FROM Circle c WHERE c.radius > 1
  run1.string pipe println
  println

  s"$dash10 Schema customization $dash10".magenta.println

  val circles = quote {
    querySchema[Circle]("circle_table", _.radius -> "radius_column")
  }

  val q2 = quote {
    circles.filter(c => c.radius > 1)
  }
  q2.ast pipe println

  val run2 = ctx.run(q2)
  // SELECT c.radius_column FROM circle_table c WHERE c.radius_column > 1
  run2.string pipe println
  println

  object schema {
    val circles    = quote {
      querySchema[Circle]("circle_table", _.radius -> "radius_column")
    }
    val rectangles = quote {
      querySchema[Rectangle]("rectangle_table", _.length -> "length_column", _.width -> "width_column")
    }
  }

  s"$dash10 Database-generated values $dash10".magenta.println

  s"$dash5 returnGenerated $dash5".green.println

  // Database generated values can be returned from an insert query by using .returningGenerated.
  // These properties will also be excluded from the insertion since they are database generated.

  case class Product(id: Int, description: String, sku: Long)

  val q3 = quote {
    query[Product]
      .insert(lift(Product(0, "My Product", 1011L)))
      .returningGenerated(_.id)
  }
  q3.ast pipe println

  val returnedIds3 = ctx.run(q3) //: List[Int]
  // INSERT INTO Product (description,sku) VALUES (?, ?) RETURNING id -- NOTE that 'id' is not being inserted.
  returnedIds3.string pipe println
  println

  // Multiple properties can be returned in a Tuple or Case Class and all of them
  // will be excluded from insertion.

  //  NOTE: Using multiple properties is currently supported by Postgres, Oracle and SQL Server

  // Assuming sku is generated by the database.
  val q4 = quote {
    query[Product]
      .insert(lift(Product(0, "My Product", 1011L)))
      .returningGenerated(p => (p.id, p.sku))
  }
  q4.ast pipe println

  val returnedIds4 = ctx.run(q4) //: List[(Int, Long)]
  // INSERT INTO Product (description) VALUES (?) RETURNING id, sku -- NOTE that 'id' and 'sku' are not being inserted.
  returnedIds4.string pipe println
  println

  s"$dash5 returning $dash5".green.println

  // In certain situations, we might want to return fields that are not auto generated as well.
  // In this case we do not want the fields to be automatically excluded from the insertion.
  // The returning method is used for that.

  val q5 = quote {
    query[Product]
      .insert(lift(Product(0, "My Product", 1011L)))
      .returning(p => (p.id, p.description))
  }
  q5.ast pipe println

  val returnedIds5 = ctx.run(q5) //: List[(Int, String)]
  // INSERT INTO Product (id, description, sku) VALUES (?, ?, ?) RETURNING id, description
  returnedIds5.string pipe println
  println

  // Wait a second! Why did we just insert id into the database? That is because
  // returning does not exclude values from the insertion! We can fix this situation
  // by manually specifying the columns to insert:

  val q6 = quote {
    query[Product]
      .insert(_.description -> "My Product", _.sku -> 1011L)
      .returning(p => (p.id, p.description))
  }
  q6.ast pipe println

  val returnedIds6 = ctx.run(q6) //: List[(Int, String)]
  // INSERT INTO Product (description, sku) VALUES (?, ?) RETURNING id, description
  returnedIds6.string pipe println
  println

  // We can also fix this situation by using an insert-meta.

  implicit val productInsertMeta = insertMeta[Product](_.id)
  val q7                         = quote {
    query[Product]
      .insert(lift(Product(0, "My Product", 1011L)))
      .returning(p => (p.id, p.description))
  }
  q7.ast pipe println

  val returnedIds7 = ctx.run(q7) //: List[(Int, String)]
  // INSERT INTO Product (description, sku) VALUES (?, ?) RETURNING id, description
  returnedIds7.string pipe println
  println

  s"$dash5 update returning $dash5".green.println

  // returning can also be used after update:

  val q8 = quote {
    query[Product]
      .update(lift(Product(42, "Updated Product", 2022L)))
      .returning(r => (r.id, r.description))
  }
  q8.ast pipe println

  val updated = ctx.run(q8) //: List[(Int, String)]
  // UPDATE Product SET id = ?, description = ?, sku = ? RETURNING id, description
  updated.string pipe println
  println

  s"$dash10 Customization $dash10".magenta.println

  s"$dash5 Postgres $dash5".green.println

  // The returning and returningGenerated methods also support arithmetic operations,
  // SQL UDFs and even entire queries. These are inserted directly into the SQL RETURNING clause.

  // Assuming this basic query:

  val q9 = quote {
    query[Product].insert(_.description -> "My Product", _.sku -> 1011L)
  }
  q9.ast pipe println

  // Add 100 to the value of id:
  val run9a = ctx.run(q9.returning(r => r.id + 100)) //: List[Int]
  // INSERT INTO Product (description, sku) VALUES (?, ?) RETURNING id + 100
  run9a.string pipe println
  println

  // Pass the value of id into a UDF:
  val udf   = quote { (i: Int) => infix"myUdf($i)".as[Int] }
  val run9b = ctx.run(q9.returning(r => udf(r.id))) //: List[Int]
  // INSERT INTO Product (description, sku) VALUES (?, ?) RETURNING myUdf(id)
  run9b.string pipe println
  println

  // Use the return value of sku to issue a query:
  case class Supplier(id: Int, clientSku: Long)
  val run9c = ctx.run {
    q9.returning(r =>
      query[Supplier]
        .filter(s => s.clientSku == r.sku)
        .map(_.id)
        .max
    )
  } //: List[Option[Long]]
  // INSERT INTO Product (description,sku) VALUES ('My Product', 1011) RETURNING (SELECT MAX(s.id) FROM Supplier s WHERE s.sku = clientSku)
  run9c.string pipe println
  println

  // As is typically the case with Quill, you can use all of these features together.

  val run9d = ctx.run {
    q9.returning(r =>
      (
        r.id + 100,
        udf(r.id),
        query[Supplier]
          .filter(s => s.clientSku == r.sku)
          .map(_.id)
          .max
      )
    )
  } // List[(Int, Int, Option[Long])]
  // INSERT INTO Product (description,sku) VALUES ('My Product', 1011)
  // RETURNING id + 100, myUdf(id), (SELECT MAX(s.id) FROM Supplier s WHERE s.sku = sku)
  run9d.string pipe println
  println

  s"$dash5 SQL Server $dash5".green.println

  {

    val ctx = new SqlMirrorContext(SQLServerDialect, SnakeCase)

    import ctx._

    val q1 = quote {
      query[Product]
        .insert(_.description -> "My Product", _.sku -> 1011L)
    }
    q1.ast pipe println

    val run10 = ctx.run(q1.returning(r => r.id + 100)) //: List[Int]
    // INSERT INTO Product (description, sku) OUTPUT INSERTED.id + 100 VALUES (?, ?)
    run10.string pipe println
    println

    val q2 = quote {
      query[Product]
        .update(_.description -> "Updated Product", _.sku -> 2022L)
        .returning(r => (r.id, r.description))
    }
    q2.ast pipe println

    val updated = ctx.run(q2)
    // UPDATE Product SET description = 'Updated Product', sku = 2022 OUTPUT INSERTED.id, INSERTED.description
    updated.string pipe println
    println
  }
}
