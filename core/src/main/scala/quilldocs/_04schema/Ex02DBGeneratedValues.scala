package quilldocs._04schema

import hutil.stringformat._

import io.getquill._

object Ex02DBGeneratedValues extends hutil.App {

  import quilldocs._

  val ctx = new SqlMirrorContext(PostgresDialect, SnakeCase)
  import ctx._

  s"$dash10 Database-generated values $dash10".magenta.println()

  s"$dash5 returnGenerated $dash5".green.println()

  // Database generated values can be returned from an insert query by using .returningGenerated.
  // These properties will also be excluded from the insertion since they are database generated.

  case class Product(id: Int, description: String, sku: Long)

  val q3 = quote {
    query[Product]
      .insert(lift(Product(0, "My Product", 1011L)))
      .returningGenerated(_.id)
  }
  printAstAndStatement(q3.ast, ctx.run(q3).string)
  // INSERT INTO Product (description,sku) VALUES (?, ?) RETURNING id -- NOTE that 'id' is not being inserted.

  // Multiple properties can be returned in a Tuple or Case Class and all of them
  // will be excluded from insertion.

  //  NOTE: Using multiple properties is currently supported by Postgres, Oracle and SQL Server

  // Assuming sku is generated by the database.
  val q4 = quote {
    query[Product]
      .insert(lift(Product(0, "My Product", 1011L)))
      .returningGenerated(p => (p.id, p.sku))
  }
  printAstAndStatement(q4.ast, ctx.run(q4).string)
  // INSERT INTO Product (description) VALUES (?) RETURNING id, sku -- NOTE that 'id' and 'sku' are not being inserted.

  s"$dash5 returning $dash5".green.println()

  // In certain situations, we might want to return fields that are not auto generated as well.
  // In this case we do not want the fields to be automatically excluded from the insertion.
  // The returning method is used for that.

  val q5 = quote {
    query[Product]
      .insert(lift(Product(0, "My Product", 1011L)))
      .returning(p => (p.id, p.description))
  }
  printAstAndStatement(q5.ast, ctx.run(q5).string)
  // INSERT INTO Product (id, description, sku) VALUES (?, ?, ?) RETURNING id, description

  // Wait a second! Why did we just insert id into the database? That is because
  // returning does not exclude values from the insertion! We can fix this situation
  // by manually specifying the columns to insert:

  val q6 = quote {
    query[Product]
      .insert(_.description -> "My Product", _.sku -> 1011L)
      .returning(p => (p.id, p.description))
  }
  printAstAndStatement(q6.ast, ctx.run(q6).string)
  // INSERT INTO Product (description, sku) VALUES (?, ?) RETURNING id, description

  // We can also fix this situation by using an insert-meta.

  implicit val productInsertMeta = insertMeta[Product](_.id)
  val q7                         = quote {
    query[Product]
      .insert(lift(Product(0, "My Product", 1011L)))
      .returning(p => (p.id, p.description))
  }
  printAstAndStatement(q7.ast, ctx.run(q7).string)
  // INSERT INTO Product (description, sku) VALUES (?, ?) RETURNING id, description

  s"$dash5 update returning $dash5".green.println()

  // returning can also be used after update:

  val q8 = quote {
    query[Product]
      .update(lift(Product(42, "Updated Product", 2022L)))
      .returning(r => (r.id, r.description))
  }
  printAstAndStatement(q8.ast, ctx.run(q8).string)
  // UPDATE Product SET id = ?, description = ?, sku = ? RETURNING id, description
}
